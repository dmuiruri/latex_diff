\subsection{Model training}

\underline{\emph{ML algorithm selection and transfer learning}}
are commonly occurring practices. Selection of ML algorithms is \DIFdelbegin \DIFdel{largely }\DIFdelend influenced by training data type and formulation of the learning problem during requirement elicitation. Heuristics are used in cases H and I to complement ML algorithms, in both cases, an explicable decision based on \DIFdelbegin \DIFdel{heuristic algorithms is highly regarded compared to an }\DIFdelend \DIFaddbegin \DIFadd{heuristics is preferred compared to a }\DIFaddend ML solution with high \DIFdelbegin \DIFdel{accuracy but largely }\DIFdelend \DIFaddbegin \DIFadd{prediction accuracy but }\DIFaddend inexplicable. The \DIFdelbegin \DIFdel{trade-offs arise either due to regulatory constraints or where a heuristic based approach provides a much simpler solution compared to a complex ML with a closely similar result}\DIFdelend \DIFaddbegin \DIFadd{ML-heuristic trade-off tend to arise due to business sector regulatory constraints}\DIFaddend .

%A similar learning problem can be approached in different ways, for example the problem of extracting information from documents addressed in Cases B and C. A pre-study conducted in Case B showed an NLP approach not to be fit for their problem instead two supervised ML models are used. One model is based on convolutional variational layers using a Bayesian approach and mostly handles non-machine readable documents with an image of the document as input. The second model is a convolutional pyramid model based on convolutional neural networks (CNN) layers used mostly for machine readable invoices with a chargrid compressed image as input. A clustering algorithm is also used in the second model to automatically group the documents into similarity groups e.g., documents from different suppliers. Case C implements classifiers based on CNN to recognize the types of document images.

Transfer learning is \DIFdelbegin \DIFdel{indicated as the main approach to train NN efficiently since model parameters can take a long time to converge and require }\DIFdelend \DIFaddbegin \DIFadd{typically used to train large NN efficiently for example in speech recognition and computer vision settings. Mainly because model convergence can be a prolonged process that requires }\DIFaddend significant computing resources. Transfer learning is based \DIFdelbegin \DIFdel{either }\DIFdelend on publicly available models or proprietary models.

Computer vision systems in cases A and F \DIFdelbegin \DIFdel{make use of transfer learning by applying state of the art models available on a wide range of }\DIFdelend \DIFaddbegin \DIFadd{utilise transfer learning to test different }\DIFaddend CNN architectures. Case M's NLP solution \DIFdelbegin \DIFdel{was also }\DIFdelend \DIFaddbegin \DIFadd{is }\DIFaddend trained using transfer learning mainly to overcome data insufficiency challenges. Case B applies transfer learning based on proprietary models as a cost management strategy. 
%The setup consists of an ensemble of six models and each model is trained for 15 epochs. If the training data set is too large, one epoch can take up to 5 hours, meaning a total of 450 hours computing hours to train the entire ensemble. When transfer learning is applied, only the last 4 epochs are trained which provides significant cost reduction. Essentially, case B maintains two training cycles, a low frequency training of large models and higher frequency training cycle based on transfer learning.

Training NN without \DIFdelbegin \DIFdel{using }\DIFdelend transfer learning can \DIFdelbegin \DIFdel{also be motivated by several factors we observe }\DIFdelend \DIFaddbegin \DIFadd{be driven by two factors observed }\DIFaddend in case D and E. \DIFdelbegin \DIFdel{(1) The amount of data is considered sufficient }\DIFdelend \DIFaddbegin \DIFadd{One, there is sufficient data and computing resources }\DIFaddend for training a model to convergence. \DIFdelbegin \DIFdel{(2) Availability of required computing resources. (3) Limited availability of relevant }\DIFdelend \DIFaddbegin \DIFadd{Two, there is a limited availability of suitable }\DIFaddend open-source models\DIFdelbegin \DIFdel{in a domain}\DIFdelend . %Case D and E projects train the ASR models with their own data. Research grants or credits provided by their cloud providers facilitated access to computing infrastructure in the early phase of the project. A full model training cycle in case E can relatively take two weeks, for example Case D's training data had low resource for Finnish languages within the healthcare sector.

\underline{\emph{ML frameworks}}
used across the cases can be broadly categorized as either Neural Network (NN) or classical (non-NN) \DIFdelbegin \DIFdel{ML solutions. Tensorflow (https://bit.ly/38sgWc4) and PyTorch (https://bit.ly/3gMHnxG) }\DIFdelend \DIFaddbegin \DIFadd{frameworks. Tensorflow-Keras and PyTorch }\DIFaddend are the two commonly used frameworks for developing \DIFdelbegin \DIFdel{DL }\DIFdelend \DIFaddbegin \DIFadd{NN }\DIFaddend models as summarised in Table~\DIFdelbegin \DIFdel{\ref{tab:data_source_storage_mlframeworks}.
Practitioners who used TensorFlow tended to make use of the Keras (https://keras.io/) framework which abstracts the low-level syntax found in the native TensorFlow framework.
}\DIFdelend \DIFaddbegin \DIFadd{\ref{tab:data_source_storage_mlframeworks_interviewees}.
}\DIFaddend 

Although \DIFdelbegin \DIFdel{NN frameworks }\DIFdelend \DIFaddbegin \DIFadd{ML frameworks may }\DIFaddend provide similar core features, \DIFdelbegin \DIFdel{a few factors can affect }\DIFdelend the choice of framework \DIFdelbegin \DIFdel{. (1) }\DIFdelend \DIFaddbegin \DIFadd{can be based on }\DIFaddend a framework's usability, \DIFdelbegin \DIFdel{(2) }\DIFdelend \DIFaddbegin \DIFadd{flexibility or }\DIFaddend a framework's underlying efficiency in utilizing computing resources\DIFdelbegin \DIFdel{, (3) a framework's flexibility. A case in point, cases }\DIFdelend \DIFaddbegin \DIFadd{. For example, both case }\DIFaddend D and E develop \DIFdelbegin \DIFdel{an ASR solutions }\DIFdelend \DIFaddbegin \DIFadd{ASR models }\DIFaddend but make use of Kaldi and PyTorch frameworks respectively. %Similarly, NLP models in cases M and N were developed using PyTorch and Watson (https://ibm.co/3BrGa6P) respectively. 
Frameworks can mature into \DIFdelbegin \DIFdel{certain domains much later }\DIFdelend \DIFaddbegin \DIFadd{specific domains at varying rates }\DIFaddend and therefore teams might \DIFdelbegin \DIFdel{seemingly use }\DIFdelend \DIFaddbegin \DIFadd{adopt }\DIFaddend different frameworks out of such historical reasons. %DIF < In non-DL setups, Scikit-Learn (https://bit.ly/3t2jyqH) and XGBoost (https://bit.ly/3t4lKhw) were dominant frameworks/libraries used to implement ML solutions.
\DIFdelbegin \DIFdel{Specialised analytics }\DIFdelend \DIFaddbegin \DIFadd{Analytics }\DIFaddend frameworks such as Spark \DIFdelbegin \DIFdel{(https://bit.ly/3gLVtQ7) }\DIFdelend also feature in case I. \DIFdelbegin \DIFdel{We generally note that team members freely adopt frameworks suitable for accomplishing tasks efficiently. %DIF < This was however best supported in two scenarios: (1) Teams with a pre-defined data type abstraction as discussed in the previous data storage formats section, accompanied by a dedicated team to manage deployment operations e.g., in case G. (2) When modelling results do not require elaborate deployment techniques, often the end result is a report or exploratory analysis. 
}\DIFdelend %DIF > We generally note that team members freely adopt frameworks suitable for accomplishing tasks efficiently. %This was however best supported in two scenarios: (1) Teams with a pre-defined data type abstraction as discussed in the previous data storage formats section, accompanied by a dedicated team to manage deployment operations e.g., in case G. (2) When modelling results do not require elaborate deployment techniques, often the end result is a report or exploratory analysis. 
%For instance, Case N indicated one team member's preference to use R (https://bit.ly/3zwVoqK) and RStudio (https://bit.ly/38s1hcS) in generating reports and analysis while the rest of the team mainly uses Python and Python based frameworks.
% Ad-hoc experiments
% An alternative view pertaining to model training relates to whether the setup is an IoT or a non-IoT setting. IoT settings often mean that data is streamed from multiple devices or sensors and setups in cases A, I, and J were observed to l

%The ML problem of extracting information from documents, is addressed in Cases B and C using different approaches. A pre-study conducted in Case B showed an NLP approach not to be fit for their problem instead two supervised ML models are used. One model is based on variational convolutional of layers using a Bayesian approach and mostly handles non-machine readable invoices. The model takes as input an image of an invoice and outputs the extracted fields from the image. Specifically, an OCR is used to extract characters from the image and these are combined and fed into the model so as to get the recognized values. The second model is a convolutional pyramid model based on CNN layers used mostly for machine readable invoices. The second model takes as input a chargrid compressed image of an invoice and outputs a heatmap that highlights areas of interest for text extraction. A clustering algorithm is also used in the second model to automatically group the invoices into similarity groups e.g., invoices from different suppliers. On the other hands, Case C implements classifiers based on CNN to recognize the types of document images 
% Case C: for the fieldsâ€™ recognition side, so we basically try to identify which document arrives to us. And we were testing convolutional neural networks, and see how these convolutional neural networks, and text analysis, and combination of these, the accuracy is something like fully around 93/ 94%. And once we know what document we have at hand, then we need to see the kind of template to, because we are getting a lot of pictures taken with a smartphone and they have skew errors,  perspective errors and we're trying to fix them with keypoint descriptors, with image alignment, basically. And once we know that, and we know in which x and y coordinates we have relevant fields in the templates that we can OCR the specific coordinates. A bit unstructured data a bit more structured
% For Case B, models are trained using Tensorflow and one training cycle is for six models trained from the scratch. For re-training transfer learning is used to train pre-trained models on new data.

Overall, challenges in model training relate to infrastructure costs, complexities of tuning and identifying explainable factors about a model's performance. 

\subsection{Model evaluation and experiment management}
Model training is \DIFdelbegin \DIFdel{considerably }\DIFdelend an iterative process \DIFdelbegin \DIFdel{involving (1) }\DIFdelend \DIFaddbegin \DIFadd{with distinct stages; }\DIFaddend determining suitability of data and algorithms, \DIFdelbegin \DIFdel{(2) parameter andhyperparameter optimization and (3) }\DIFdelend \DIFaddbegin \DIFadd{parameter and/or hyper-parameter optimization and }\DIFaddend model evaluation. %DIF < These iterations result in multiple model variants with their respective attributes, such as accuracy and parameter settings, which calls for 
Managing metadata from these \DIFdelbegin \DIFdel{experiments makes the training process }\DIFdelend \DIFaddbegin \DIFadd{stages makes the ML workflow }\DIFaddend traceable and reproducible.
%DIF > These iterations result in multiple model variants with their respective attributes, such as accuracy and parameter settings, which calls for 

We note three unique approaches used to evaluate models\DIFdelbegin \DIFdel{: (1) Data is stored such that itcan be stratified by quality allowing composition of }\DIFdelend \DIFaddbegin \DIFadd{. One, data is stored according to it's quality which makes it possible to compose datasets with different levels of quality for }\DIFaddend training and validation \DIFdelbegin \DIFdel{data to include different quality }\DIFdelend \DIFaddbegin \DIFadd{purposes }\DIFaddend (Cases D and E)\DIFdelbegin \DIFdel{, (2) Use of ensemble of models each }\DIFdelend \DIFaddbegin \DIFadd{. The second approach makes use of model ensembles where each model is }\DIFaddend trained on a unique subset of the data (Case B)\DIFdelbegin \DIFdel{and (3) Use of }\DIFdelend \DIFaddbegin \DIFadd{. The third approach applies }\DIFaddend a configurable inference algorithm where each configuration makes use of a unique adaptation of the model (Case E). %In the third setup, a model is composed of a core part supporting feature sharing and different adaption layers tuned for specific use cases. Each configuration of the model has an associated test data used to validate the model. This was encountered in case E where 30 to 40 configurations of the model were maintained.

To manage model evaluation results\DIFdelbegin \DIFdel{from these kinds of setups}\DIFdelend , case organizations either use dedicated experiment tracking tools \DIFdelbegin \DIFdel{case (}\DIFdelend \DIFaddbegin \DIFadd{(case }\DIFaddend G, I, N, O and P), logging process metadata (case B, E, F) or generating hashes (case D). \DIFdelbegin \DIFdel{These approaches are summarised in Table~\ref{tab:databases}. 
}\DIFdelend \DIFaddbegin \DIFadd{Hashing involves computing hash values on given combinations of ML artifacts (data, configurations, model) following execution of a ML pipeline.
}\DIFaddend 

\DIFdelbegin \DIFdel{Case D uses hashing such that a hash is computed from a given version of the datacombined with a model's parameters. The resulting hash is stored for later reference. Obtaining a previously stored hash implies that a model if similar characteristics already exists.
%DIF < based on that data version and parameter settings has been previously trained and the model can be identified by a given version number. 
}\DIFdelend %DIF > Case D uses hashing such that a hash is computed from a given version of the data combined with a model's parameters. The resulting hash is stored for later reference. Obtaining a previously stored hash implies that a model if similar characteristics already exists. %based on that data version and parameter settings has been previously trained and the model can be identified by a given version number. 

Case E and F \DIFdelbegin \DIFdel{utilize the generation and collection of metadata which includes metadata collected from tools such as git hashes. Case E stores metadata in a data warehouse which can be queried to produce spreadsheets reports. Case F's platform generates metadata at each step of the pipeline and resulting data is visualized on a web tool.
}\DIFdelend \DIFaddbegin \DIFadd{generate and collect metadata (E.g. git hashes) which are used to produce custom reports. These approaches are summarised in Table~\ref{tab:databases}.
}

\DIFaddend Systematic management of experiments facilitates workflow automation \DIFaddbegin \DIFadd{and further increases treacability and reproducability of ML workflows}\DIFaddend .
%The same metadata can be utilised by the MLOps platform to re-run a model using a previous configuration.

%Case P tracks experiments using two approaches. One approach makes use of the MLflow (https://bit.ly/38sttfK) tool. The second approach allows data scientists to freely generate metrics in JSON format and store them in DynamoDB (https://amzn.to/3mMHGwh). The second approach facilitates storage of metrics without following any strict schema being enforced because of the NoSQL nature of the DynamoDB. 

%In the overall, we observed that such systematic management of experiments facilitates workflow automation since data required to repeat a tracked stage of the pipeline is readily available and the transparency of the entire pipeline increased. 
